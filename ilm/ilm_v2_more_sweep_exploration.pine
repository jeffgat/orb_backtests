//@version=6
strategy(
     title              = "ILM V1",
     overlay            = true,
     initial_capital    = 100000,
     pyramiding         = 0,
     margin_long        = 0,
     margin_short       = 0,
     commission_type    = strategy.commission.cash_per_contract,
     commission_value   = 0.05,
     process_orders_on_close = true,
     use_bar_magnifier  = true,
     fill_orders_on_standard_ohlc = false
)

// ----------------------------------------------------------------------------------------
// Inputs
// ----------------------------------------------------------------------------------------
// Risk Management
riskUsd       = input.float(1000, "Risk per trade ($)", step=50)
rr            = input.float(2.0, "Reward/Risk", step=0.25)
tp1Ratio      = input.float(0.5, "Partial TP & BE Level (0.5 = 50% of target)", step=0.1, minval=0.1, maxval=0.9)
minQty        = input.float(1.0, "Min Qty", step=0.1)
qtyStep       = input.float(1.0, "Qty Step", step=0.1)
beOffsetTicks = input.int(4, "BE Offset (ticks)", step=1, tooltip="Ticks above/below entry for BE stop")

// Session Windows
entryWindow   = input.session("0830-1130", "Entry window (NY time)")
flatWindow    = input.session("1550-1600", "Flat window (NY time)")

// Killzone Sessions
asiaSession   = input.session("2000-0000", "Asia KZ (NY time)")
londonSession = input.session("0200-0500", "London KZ (NY time)")

// Strategy Settings
maxBarsAfterSweep = input.int(24, "Max bars after sweep", minval=1, maxval=50, tooltip="Setup expires if no entry within this many bars")
minGapPts         = input.float(5.0, "Min Gap Size (pts)", step=1.0, minval=0, tooltip="Minimum gap size in points to qualify as valid")
gapWindowBars     = input.int(10, "Gap Window (bars)", minval=1, maxval=50, tooltip="Only use gaps formed within this many bars before/after the sweep candle")
maxTradesPerDay   = input.int(3, "Max Trades Per Day", minval=1, maxval=10, tooltip="Maximum number of trades allowed per day")

// Sweep Type Toggles
useAsiaHighSweeps   = input.bool(true, "Use Asia High Sweeps", tooltip="Enable short setups from Asia high sweeps")
useAsiaLowSweeps    = input.bool(true, "Use Asia Low Sweeps", tooltip="Enable long setups from Asia low sweeps")
useLondonHighSweeps = input.bool(true, "Use London High Sweeps", tooltip="Enable short setups from London high sweeps")
useLondonLowSweeps  = input.bool(true, "Use London Low Sweeps", tooltip="Enable long setups from London low sweeps")
usePDHSweeps        = input.bool(true, "Use PDH Sweeps", tooltip="Enable short setups from previous day high sweeps")
usePDLSweeps        = input.bool(true, "Use PDL Sweeps", tooltip="Enable long setups from previous day low sweeps")
use1HSwingHighSweeps = input.bool(false, "Use 1H Swing High Sweeps", tooltip="Enable short setups from 1H swing high sweeps")
use1HSwingLowSweeps  = input.bool(false, "Use 1H Swing Low Sweeps", tooltip="Enable long setups from 1H swing low sweeps")
swingLength          = input.int(48, "Swing Pivot Length", minval=2, maxval=50, tooltip="Lookback/lookforward bars for swing pivot detection on 1H timeframe")

// ----------------------------------------------------------------------------------------
// Timeframe check (works on any intraday timeframe)
// ----------------------------------------------------------------------------------------
isIntraday = timeframe.isintraday
barClosed = barstate.isconfirmed

// ----------------------------------------------------------------------------------------
// Session Detection
// ----------------------------------------------------------------------------------------
tz = "America/New_York"

inAsia      = not na(time(timeframe.period, asiaSession, tz))
inAsiaPrev  = not na(time(timeframe.period, asiaSession, tz)[1])
asiaJustEnded = not inAsia and inAsiaPrev

inLondon      = not na(time(timeframe.period, londonSession, tz))
inLondonPrev  = not na(time(timeframe.period, londonSession, tz)[1])
londonJustEnded = not inLondon and inLondonPrev

inEntryWin = not na(time(timeframe.period, entryWindow, tz))
inEntryWinPrev = not na(time(timeframe.period, entryWindow, tz)[1])
entryWinJustStarted = inEntryWin and not inEntryWinPrev

inFlatWin  = not na(time(timeframe.period, flatWindow, tz))

afterCutoff = not inEntryWin

// New trading day
newDay = ta.change(time("D")) != 0

// ----------------------------------------------------------------------------------------
// Killzone Level Tracking (Asia and London tracked separately)
// ----------------------------------------------------------------------------------------
// Temporary tracking during Asia session
var float tempAsiaHigh = na
var float tempAsiaLow  = na
var int   tempAsiaHighBar = na
var int   tempAsiaLowBar  = na

// Temporary tracking during London session
var float tempLondonHigh = na
var float tempLondonLow  = na
var int   tempLondonHighBar = na
var int   tempLondonLowBar  = na

// Asia killzone levels (locked after session ends)
var float asiaHigh = na
var float asiaLow  = na
var int   asiaHighBar = na
var int   asiaLowBar  = na
var bool  asiaHighSwept  = false
var bool  asiaLowSwept   = false
var bool  asiaHighTraded = false
var bool  asiaLowTraded  = false
var int   asiaHighSweepBar = na
var int   asiaLowSweepBar = na

// London killzone levels (locked after session ends)
var float londonHigh = na
var float londonLow  = na
var int   londonHighBar = na
var int   londonLowBar  = na
var bool  londonHighSwept  = false
var bool  londonLowSwept   = false
var bool  londonHighTraded = false
var bool  londonLowTraded  = false
var int   londonHighSweepBar = na
var int   londonLowSweepBar = na

// Track H/L during Asia session
if inAsia
    if na(tempAsiaHigh) or high > tempAsiaHigh
        tempAsiaHigh := high
        tempAsiaHighBar := bar_index
    if na(tempAsiaLow) or low < tempAsiaLow
        tempAsiaLow := low
        tempAsiaLowBar := bar_index

// Track H/L during London session
if inLondon
    if na(tempLondonHigh) or high > tempLondonHigh
        tempLondonHigh := high
        tempLondonHighBar := bar_index
    if na(tempLondonLow) or low < tempLondonLow
        tempLondonLow := low
        tempLondonLowBar := bar_index

// Lock Asia levels when session ends
if asiaJustEnded and not na(tempAsiaHigh) and not na(tempAsiaLow)
    asiaHigh := tempAsiaHigh
    asiaLow  := tempAsiaLow
    asiaHighBar := tempAsiaHighBar
    asiaLowBar := tempAsiaLowBar
    asiaHighSwept := false
    asiaLowSwept := false
    asiaHighTraded := false
    asiaLowTraded := false
    asiaHighSweepBar := na
    asiaLowSweepBar := na
    tempAsiaHigh := na
    tempAsiaLow := na
    tempAsiaHighBar := na
    tempAsiaLowBar := na

// Lock London levels when session ends
if londonJustEnded and not na(tempLondonHigh) and not na(tempLondonLow)
    londonHigh := tempLondonHigh
    londonLow  := tempLondonLow
    londonHighBar := tempLondonHighBar
    londonLowBar := tempLondonLowBar
    londonHighSwept := false
    londonLowSwept := false
    londonHighTraded := false
    londonLowTraded := false
    londonHighSweepBar := na
    londonLowSweepBar := na
    tempLondonHigh := na
    tempLondonLow := na
    tempLondonHighBar := na
    tempLondonLowBar := na

// ----------------------------------------------------------------------------------------
// Previous Day High/Low Tracking
// ----------------------------------------------------------------------------------------
var float pdh = na
var float pdl = na
var int   pdhBar = na
var int   pdlBar = na
var bool  pdhSwept = false
var bool  pdlSwept = false
var bool  pdhTraded = false
var bool  pdlTraded = false
var int   pdhSourceTime = na  // Timestamp when PDH/PDL was set (to ensure we only use previous day)

// ----------------------------------------------------------------------------------------
// 1H Swing High/Low Detection (using HTF security call)
// ----------------------------------------------------------------------------------------
// Get 1H pivot highs and lows using request.security
[htfPivotHigh, htfPivotLow, htfHigh, htfLow] = request.security(syminfo.tickerid, "60", [ta.pivothigh(high, swingLength, swingLength), ta.pivotlow(low, swingLength, swingLength), high, low])

// Track the most recent 1H swing high/low levels
var float swingHigh1H = na
var float swingLow1H = na
var int   swingHigh1HBar = na
var int   swingLow1HBar = na
var bool  swingHigh1HSwept = false
var bool  swingLow1HSwept = false
var bool  swingHigh1HTraded = false
var bool  swingLow1HTraded = false
var int   swingHigh1HSweepBar = na
var int   swingLow1HSweepBar = na

// Flags to detect new swing pivots for visualization
newSwingHighDetected = false
newSwingLowDetected = false

// Update swing high when a new pivot is detected
if not na(htfPivotHigh) and (na(swingHigh1H) or htfPivotHigh != swingHigh1H)
    swingHigh1H := htfPivotHigh
    swingHigh1HBar := bar_index - swingLength  // Pivot is confirmed swingLength bars ago
    swingHigh1HSwept := false
    swingHigh1HTraded := false
    swingHigh1HSweepBar := na
    newSwingHighDetected := true

// Update swing low when a new pivot is detected
if not na(htfPivotLow) and (na(swingLow1H) or htfPivotLow != swingLow1H)
    swingLow1H := htfPivotLow
    swingLow1HBar := bar_index - swingLength  // Pivot is confirmed swingLength bars ago
    swingLow1HSwept := false
    swingLow1HTraded := false
    swingLow1HSweepBar := na
    newSwingLowDetected := true

// Track current day's high/low
var float currentDayHigh = na
var float currentDayLow = na
var int   currentDayHighBar = na
var int   currentDayLowBar = na
var int   currentDayStartTime = na  // Track current day start timestamp

if newDay
    // Lock previous day's levels
    pdh := currentDayHigh
    pdl := currentDayLow
    pdhBar := currentDayHighBar
    pdlBar := currentDayLowBar
    pdhSwept := false
    pdlSwept := false
    pdhTraded := false
    pdlTraded := false
    pdhSourceTime := currentDayStartTime  // Remember when these levels are from
    // Reset current day tracking
    currentDayHigh := high
    currentDayLow := low
    currentDayHighBar := bar_index
    currentDayLowBar := bar_index
    currentDayStartTime := time
else
    if na(currentDayStartTime)
        currentDayStartTime := time
    if na(currentDayHigh) or high > currentDayHigh
        currentDayHigh := high
        currentDayHighBar := bar_index
    if na(currentDayLow) or low < currentDayLow
        currentDayLow := low
        currentDayLowBar := bar_index

// Check if PDH/PDL is from the previous day (not older)
// Previous day means the source time is within 2 calendar days (accounts for weekends)
msPerDay = 24 * 60 * 60 * 1000
daysSincePdh = na(pdhSourceTime) ? na : (time - pdhSourceTime) / msPerDay
isPdhFromPreviousDay = not na(daysSincePdh) and daysSincePdh >= 0 and daysSincePdh < 4  // Allow up to 4 days for weekends

// ----------------------------------------------------------------------------------------
// Setup State Machine
// ----------------------------------------------------------------------------------------
var bool  waitingForGap       = false
var bool  waitingForInversion = false
var string sweepType          = na      // "bullish" (for long after low sweep) or "bearish" (for short after high sweep)
var string sweepSource        = na      // "asiaHigh", "asiaLow", "londonHigh", "londonLow", "pdh", "pdl", "1hSwingHigh", "1hSwingLow"
var int   sweepBar            = na
var int   barsAfterSweep      = 0
var int   tradesToday         = 0       // Counter for trades taken today

// Track actual sweep bar indices (when price first trades through level)
var int pdhSweepBar = na
var int pdlSweepBar = na

// Gap storage
var float gapTop    = na
var float gapBottom = na
var bool  gapIsBullish = false
var int   gapBar    = na
var float gapImpulseLow  = na  // Low of the impulse candle (for long stop)
var float gapImpulseHigh = na  // High of the impulse candle (for short stop)

// Position tracking
var float longStopStored     = na
var float longTargetStored   = na
var float longHalfwayStored  = na
var float longEntryStored    = na
var float longQtyStored      = na
var float longHalfQty        = na
var bool  longBEActive       = false
var bool  longSingleContract = false
var float longFilledEntry    = na

var float shortStopStored     = na
var float shortTargetStored   = na
var float shortHalfwayStored  = na
var float shortEntryStored    = na
var float shortQtyStored      = na
var float shortHalfQty        = na
var bool  shortBEActive       = false
var bool  shortSingleContract = false
var float shortFilledEntry    = na


// ----------------------------------------------------------------------------------------
// Daily Reset
// ----------------------------------------------------------------------------------------
if newDay
    // Reset daily trade counter
    tradesToday := 0

    // Reset Asia killzone levels
    asiaHigh := na
    asiaLow := na
    asiaHighBar := na
    asiaLowBar := na
    asiaHighSwept := false
    asiaLowSwept := false
    asiaHighTraded := false
    asiaLowTraded := false
    asiaHighSweepBar := na
    asiaLowSweepBar := na
    tempAsiaHigh := na
    tempAsiaLow := na
    tempAsiaHighBar := na
    tempAsiaLowBar := na

    // Reset London killzone levels
    londonHigh := na
    londonLow := na
    londonHighBar := na
    londonLowBar := na
    londonHighSwept := false
    londonLowSwept := false
    londonHighTraded := false
    londonLowTraded := false
    londonHighSweepBar := na
    londonLowSweepBar := na
    tempLondonHigh := na
    tempLondonLow := na
    tempLondonHighBar := na
    tempLondonLowBar := na

    // Note: PDH/PDL are updated in the PDH/PDL tracking section above
    // Only reset the swept/traded flags here (levels are set from previous day)
    // pdhSwept, pdlSwept, pdhTraded, pdlTraded are reset in the PDH/PDL section

    // Reset sweep bar tracking
    pdhSweepBar := na
    pdlSweepBar := na
    swingHigh1HSweepBar := na
    swingLow1HSweepBar := na

    // Reset 1H swing traded flags (allow trading same level on new day)
    // Note: swingHigh1H/swingLow1H levels persist - only updated when new pivots form
    swingHigh1HTraded := false
    swingLow1HTraded := false

    // Reset setup state
    waitingForGap := false
    waitingForInversion := false
    sweepType := na
    sweepSource := na
    sweepBar := na
    barsAfterSweep := 0

    // Reset gap storage
    gapTop := na
    gapBottom := na
    gapIsBullish := false
    gapBar := na
    gapImpulseLow := na
    gapImpulseHigh := na

    // Reset position tracking
    longStopStored := na
    longTargetStored := na
    longHalfwayStored := na
    longEntryStored := na
    longQtyStored := na
    longHalfQty := na
    longBEActive := false
    longSingleContract := false
    longFilledEntry := na

    shortStopStored := na
    shortTargetStored := na
    shortHalfwayStored := na
    shortEntryStored := na
    shortQtyStored := na
    shortHalfQty := na
    shortBEActive := false
    shortSingleContract := false
    shortFilledEntry := na

    strategy.cancel_all()

// ----------------------------------------------------------------------------------------
// Sweep Detection
// ----------------------------------------------------------------------------------------
// Detect when levels are actually swept (anytime, not just entry window)
// This is used for visualization and timing validation
if barClosed and isIntraday
    // Asia sweeps
    if not na(asiaHigh) and not asiaHighSwept and high > asiaHigh
        asiaHighSwept := true
        asiaHighSweepBar := bar_index
    if not na(asiaLow) and not asiaLowSwept and low < asiaLow
        asiaLowSwept := true
        asiaLowSweepBar := bar_index
    // London sweeps
    if not na(londonHigh) and not londonHighSwept and high > londonHigh
        londonHighSwept := true
        londonHighSweepBar := bar_index
    if not na(londonLow) and not londonLowSwept and low < londonLow
        londonLowSwept := true
        londonLowSweepBar := bar_index
    // PDH/PDL sweeps
    if not na(pdh) and not pdhSwept and high > pdh
        pdhSwept := true
        pdhSweepBar := bar_index
    if not na(pdl) and not pdlSwept and low < pdl
        pdlSwept := true
        pdlSweepBar := bar_index
    // 1H Swing sweeps
    if not na(swingHigh1H) and not swingHigh1HSwept and high > swingHigh1H
        swingHigh1HSwept := true
        swingHigh1HSweepBar := bar_index
    if not na(swingLow1H) and not swingLow1HSwept and low < swingLow1H
        swingLow1HSwept := true
        swingLow1HSweepBar := bar_index

// Only start setups during entry window when not already in a setup and under daily trade limit
canDetectSweepBase = isIntraday and barClosed and inEntryWin and strategy.position_size == 0 and not waitingForGap and not waitingForInversion and tradesToday < maxTradesPerDay

// Asia High sweep -> bearish setup (looking for short)
canDetectAsiaSweep = canDetectSweepBase and not na(asiaHigh) and not na(asiaLow)
if canDetectAsiaSweep and asiaHighSwept and not asiaHighTraded and not na(asiaHighSweepBar) and (bar_index - asiaHighSweepBar) <= gapWindowBars and useAsiaHighSweeps
    asiaHighTraded := true  // Mark as traded to prevent re-entry
    sweepType := "bearish"
    sweepSource := "asiaHigh"
    sweepBar := asiaHighSweepBar  // Use actual sweep bar, not current bar
    barsAfterSweep := bar_index - asiaHighSweepBar  // Account for bars already passed
    waitingForGap := true
    // Reset any prior gap data
    gapTop := na
    gapBottom := na
    gapIsBullish := false
    gapBar := na

// Asia Low sweep -> bullish setup (looking for long)
if canDetectAsiaSweep and asiaLowSwept and not asiaLowTraded and not na(asiaLowSweepBar) and (bar_index - asiaLowSweepBar) <= gapWindowBars and useAsiaLowSweeps
    asiaLowTraded := true  // Mark as traded to prevent re-entry
    sweepType := "bullish"
    sweepSource := "asiaLow"
    sweepBar := asiaLowSweepBar  // Use actual sweep bar, not current bar
    barsAfterSweep := bar_index - asiaLowSweepBar  // Account for bars already passed
    waitingForGap := true
    // Reset any prior gap data
    gapTop := na
    gapBottom := na
    gapIsBullish := false
    gapBar := na

// London High sweep -> bearish setup (looking for short)
canDetectLondonSweep = canDetectSweepBase and not na(londonHigh) and not na(londonLow)
if canDetectLondonSweep and londonHighSwept and not londonHighTraded and not na(londonHighSweepBar) and (bar_index - londonHighSweepBar) <= gapWindowBars and useLondonHighSweeps
    londonHighTraded := true  // Mark as traded to prevent re-entry
    sweepType := "bearish"
    sweepSource := "londonHigh"
    sweepBar := londonHighSweepBar  // Use actual sweep bar, not current bar
    barsAfterSweep := bar_index - londonHighSweepBar  // Account for bars already passed
    waitingForGap := true
    // Reset any prior gap data
    gapTop := na
    gapBottom := na
    gapIsBullish := false
    gapBar := na

// London Low sweep -> bullish setup (looking for long)
if canDetectLondonSweep and londonLowSwept and not londonLowTraded and not na(londonLowSweepBar) and (bar_index - londonLowSweepBar) <= gapWindowBars and useLondonLowSweeps
    londonLowTraded := true  // Mark as traded to prevent re-entry
    sweepType := "bullish"
    sweepSource := "londonLow"
    sweepBar := londonLowSweepBar  // Use actual sweep bar, not current bar
    barsAfterSweep := bar_index - londonLowSweepBar  // Account for bars already passed
    waitingForGap := true
    // Reset any prior gap data
    gapTop := na
    gapBottom := na
    gapIsBullish := false
    gapBar := na

// PDH/PDL sweeps (only use levels from previous day, not older)
canDetectPdSweep = canDetectSweepBase and not na(pdh) and not na(pdl) and isPdhFromPreviousDay

// PDH sweep -> bearish setup (looking for short)
if canDetectPdSweep and pdhSwept and not pdhTraded and not na(pdhSweepBar) and (bar_index - pdhSweepBar) <= gapWindowBars and usePDHSweeps
    pdhTraded := true  // Mark as traded to prevent re-entry
    sweepType := "bearish"
    sweepSource := "pdh"
    sweepBar := pdhSweepBar  // Use actual sweep bar, not current bar
    barsAfterSweep := bar_index - pdhSweepBar  // Account for bars already passed
    waitingForGap := true
    // Reset any prior gap data
    gapTop := na
    gapBottom := na
    gapIsBullish := false
    gapBar := na

// PDL sweep -> bullish setup (looking for long)
if canDetectPdSweep and pdlSwept and not pdlTraded and not na(pdlSweepBar) and (bar_index - pdlSweepBar) <= gapWindowBars and usePDLSweeps
    pdlTraded := true  // Mark as traded to prevent re-entry
    sweepType := "bullish"
    sweepSource := "pdl"
    sweepBar := pdlSweepBar  // Use actual sweep bar, not current bar
    barsAfterSweep := bar_index - pdlSweepBar  // Account for bars already passed
    waitingForGap := true
    // Reset any prior gap data
    gapTop := na
    gapBottom := na
    gapIsBullish := false
    gapBar := na

// 1H Swing High/Low sweeps
canDetect1HSwingSweep = canDetectSweepBase and not na(swingHigh1H) and not na(swingLow1H)

// 1H Swing High sweep -> bearish setup (looking for short)
if canDetect1HSwingSweep and swingHigh1HSwept and not swingHigh1HTraded and not na(swingHigh1HSweepBar) and (bar_index - swingHigh1HSweepBar) <= gapWindowBars and use1HSwingHighSweeps
    swingHigh1HTraded := true  // Mark as traded to prevent re-entry
    sweepType := "bearish"
    sweepSource := "1hSwingHigh"
    sweepBar := swingHigh1HSweepBar  // Use actual sweep bar, not current bar
    barsAfterSweep := bar_index - swingHigh1HSweepBar  // Account for bars already passed
    waitingForGap := true
    // Reset any prior gap data
    gapTop := na
    gapBottom := na
    gapIsBullish := false
    gapBar := na

// 1H Swing Low sweep -> bullish setup (looking for long)
if canDetect1HSwingSweep and swingLow1HSwept and not swingLow1HTraded and not na(swingLow1HSweepBar) and (bar_index - swingLow1HSweepBar) <= gapWindowBars and use1HSwingLowSweeps
    swingLow1HTraded := true  // Mark as traded to prevent re-entry
    sweepType := "bullish"
    sweepSource := "1hSwingLow"
    sweepBar := swingLow1HSweepBar  // Use actual sweep bar, not current bar
    barsAfterSweep := bar_index - swingLow1HSweepBar  // Account for bars already passed
    waitingForGap := true
    // Reset any prior gap data
    gapTop := na
    gapBottom := na
    gapIsBullish := false
    gapBar := na

// ----------------------------------------------------------------------------------------
// Gap Detection (3-candle pattern)
// ----------------------------------------------------------------------------------------
// Bullish Gap: gap between bar[2] high and bar[0] low
bullishGapSize = low - high[2]
bullishGapDetected = high[2] < low and high[2] < high[1] and low[2] < low and bullishGapSize >= minGapPts
bullishGapTop = low         // top of gap (current bar low)
bullishGapBottom = high[2]  // bottom of gap (bar[2] high)

// Bearish Gap: gap between bar[2] low and bar[0] high
bearishGapSize = low[2] - high
bearishGapDetected = low[2] > high and low[2] > low[1] and high[2] > high and bearishGapSize >= minGapPts
bearishGapTop = low[2]      // top of gap (bar[2] low)
bearishGapBottom = high     // bottom of gap (current bar high)

// Detect Gap after sweep
// Gap is formed at the impulse candle (bar[1]), so check if that bar is within the window
if waitingForGap and barClosed and isIntraday
    // The impulse bar (bar[1]) is where the gap is created
    impulseBar = bar_index - 1
    gapWithinWindow = not na(sweepBar) and math.abs(impulseBar - sweepBar) <= gapWindowBars

    // For bearish setup (after high sweep): wait for BULLISH Gap
    if sweepType == "bearish" and bullishGapDetected and gapWithinWindow
        gapTop := bullishGapTop
        gapBottom := bullishGapBottom
        gapIsBullish := true
        gapBar := bar_index
        gapImpulseLow := low[1]   // Store impulse candle low
        gapImpulseHigh := high[1] // Store impulse candle high
        waitingForGap := false
        waitingForInversion := true

    // For bullish setup (after low sweep): wait for BEARISH Gap
    if sweepType == "bullish" and bearishGapDetected and gapWithinWindow
        gapTop := bearishGapTop
        gapBottom := bearishGapBottom
        gapIsBullish := false
        gapBar := bar_index
        gapImpulseLow := low[1]   // Store impulse candle low
        gapImpulseHigh := high[1] // Store impulse candle high
        waitingForGap := false
        waitingForInversion := true

// ----------------------------------------------------------------------------------------
// Setup Expiration (12 bars after sweep)
// ----------------------------------------------------------------------------------------
if (waitingForGap or waitingForInversion) and barClosed and isIntraday
    barsAfterSweep += 1

if barsAfterSweep >= maxBarsAfterSweep
    waitingForGap := false
    waitingForInversion := false
    sweepType := na
    sweepSource := na
    sweepBar := na
    barsAfterSweep := 0
    gapTop := na
    gapBottom := na
    gapIsBullish := false
    gapBar := na
    gapImpulseLow := na
    gapImpulseHigh := na

// ----------------------------------------------------------------------------------------
// Qty Rounding Helper
// ----------------------------------------------------------------------------------------
floorToStep(x, step) =>
    step <= 0 ? x : math.floor(x / step) * step

// BE offset calculation
beOffset = beOffsetTicks * syminfo.mintick

// ----------------------------------------------------------------------------------------
// Inversion Detection & Entry
// ----------------------------------------------------------------------------------------
// Also check barsAfterSweep to ensure we don't enter after setup should have expired
// Also check daily trade limit
if waitingForInversion and barClosed and isIntraday and inEntryWin and strategy.position_size == 0 and barsAfterSweep < maxBarsAfterSweep and tradesToday < maxTradesPerDay
    // Bullish Gap inversion (SHORT entry): candle closes BELOW the bullish gap
    if gapIsBullish and close < gapBottom
        // Entry calculation
        entry = close
        stop = gapImpulseHigh  // Stop at high of impulse candle
        riskPts = stop - entry

        if riskPts > 0
            qtyRaw = riskUsd / (riskPts * syminfo.pointvalue)
            qty = floorToStep(qtyRaw, qtyStep)
            isSingleContract = qty <= minQty
            halfQty = isSingleContract ? qty : floorToStep(qty / 2, qtyStep)
            halfQty := math.max(halfQty, minQty)

            if qty >= minQty
                shortStopStored := stop
                shortTargetStored := entry - rr * riskPts
                shortHalfwayStored := entry - (rr * riskPts * tp1Ratio)
                shortEntryStored := entry
                shortQtyStored := qty
                shortHalfQty := halfQty
                shortSingleContract := isSingleContract
                shortBEActive := false
                shortFilledEntry := na

                strategy.entry("S", strategy.short, qty=qty)
                tradesToday += 1  // Increment daily trade counter

                // Mark the swept level as traded
                if sweepSource == "asiaHigh"
                    asiaHighTraded := true
                else if sweepSource == "londonHigh"
                    londonHighTraded := true
                else if sweepSource == "pdh"
                    pdhTraded := true
                else if sweepSource == "1hSwingHigh"
                    swingHigh1HTraded := true
                waitingForInversion := false
                sweepType := na
                sweepSource := na
                gapTop := na
                gapBottom := na
                gapIsBullish := false

    // Bearish Gap inversion (LONG entry): candle closes ABOVE the bearish gap
    if not gapIsBullish and close > gapTop
        // Entry calculation
        entry = close
        stop = gapImpulseLow  // Stop at low of impulse candle
        riskPts = entry - stop

        if riskPts > 0
            qtyRaw = riskUsd / (riskPts * syminfo.pointvalue)
            qty = floorToStep(qtyRaw, qtyStep)
            isSingleContract = qty <= minQty
            halfQty = isSingleContract ? qty : floorToStep(qty / 2, qtyStep)
            halfQty := math.max(halfQty, minQty)

            if qty >= minQty
                longStopStored := stop
                longTargetStored := entry + rr * riskPts
                longHalfwayStored := entry + (rr * riskPts * tp1Ratio)
                longEntryStored := entry
                longQtyStored := qty
                longHalfQty := halfQty
                longSingleContract := isSingleContract
                longBEActive := false
                longFilledEntry := na

                strategy.entry("L", strategy.long, qty=qty)
                tradesToday += 1  // Increment daily trade counter

                // Mark the swept level as traded
                if sweepSource == "asiaLow"
                    asiaLowTraded := true
                else if sweepSource == "londonLow"
                    londonLowTraded := true
                else if sweepSource == "pdl"
                    pdlTraded := true
                else if sweepSource == "1hSwingLow"
                    swingLow1HTraded := true
                waitingForInversion := false
                sweepType := na
                sweepSource := na
                gapTop := na
                gapBottom := na
                gapIsBullish := false

// ----------------------------------------------------------------------------------------
// Track Actual Entry Fill Price
// ----------------------------------------------------------------------------------------
if strategy.position_size > 0 and na(longFilledEntry)
    longFilledEntry := strategy.opentrades.entry_price(0)
if strategy.position_size < 0 and na(shortFilledEntry)
    shortFilledEntry := strategy.opentrades.entry_price(0)

// ----------------------------------------------------------------------------------------
// Breakeven State Update
// ----------------------------------------------------------------------------------------
if strategy.position_size > 0
    if longSingleContract
        if not na(longHalfwayStored) and high >= longHalfwayStored
            longBEActive := true
    else
        positionReduced = strategy.position_size < longQtyStored and longQtyStored > 0 and not na(longFilledEntry)
        if (not na(longHalfwayStored) and high >= longHalfwayStored) or positionReduced
            longBEActive := true

if strategy.position_size < 0
    if shortSingleContract
        if not na(shortHalfwayStored) and low <= shortHalfwayStored
            shortBEActive := true
    else
        positionReduced = math.abs(strategy.position_size) < shortQtyStored and shortQtyStored > 0 and not na(shortFilledEntry)
        if (not na(shortHalfwayStored) and low <= shortHalfwayStored) or positionReduced
            shortBEActive := true

// ----------------------------------------------------------------------------------------
// Exit Orders
// ----------------------------------------------------------------------------------------
if strategy.position_size > 0
    beStopPrice = (not na(longFilledEntry) ? longFilledEntry : longEntryStored) + beOffset
    finalStop = longBEActive ? beStopPrice : longStopStored

    if longSingleContract
        strategy.exit("L-F", from_entry="L", stop=finalStop, limit=longTargetStored, comment_loss=longBEActive ? "l-be" : "l-sl", comment_profit="l-tp2")
    else
        strategy.exit("L-P", from_entry="L", qty=longHalfQty, stop=longStopStored, limit=longHalfwayStored, comment_loss="l-sl", comment_profit="l-tp1")
        strategy.exit("L-F", from_entry="L", stop=finalStop, limit=longTargetStored, comment_loss=longBEActive ? "l-be" : "l-sl", comment_profit="l-tp2")

if strategy.position_size < 0
    beStopPrice = (not na(shortFilledEntry) ? shortFilledEntry : shortEntryStored) - beOffset
    finalStop = shortBEActive ? beStopPrice : shortStopStored

    if shortSingleContract
        strategy.exit("S-F", from_entry="S", stop=finalStop, limit=shortTargetStored, comment_loss=shortBEActive ? "s-be" : "s-sl", comment_profit="s-tp2")
    else
        strategy.exit("S-P", from_entry="S", qty=shortHalfQty, stop=shortStopStored, limit=shortHalfwayStored, comment_loss="s-sl", comment_profit="s-tp1")
        strategy.exit("S-F", from_entry="S", stop=finalStop, limit=shortTargetStored, comment_loss=shortBEActive ? "s-be" : "s-sl", comment_profit="s-tp2")

// ----------------------------------------------------------------------------------------
// Cancel Setups After Cutoff
// ----------------------------------------------------------------------------------------
if afterCutoff
    waitingForGap := false
    waitingForInversion := false
    sweepType := na
    sweepSource := na
    sweepBar := na
    barsAfterSweep := 0
    gapTop := na
    gapBottom := na
    gapIsBullish := false
    gapBar := na
    gapImpulseLow := na
    gapImpulseHigh := na

// ----------------------------------------------------------------------------------------
// Flat at 15:50
// ----------------------------------------------------------------------------------------
if inFlatWin and strategy.position_size != 0
    if strategy.position_size > 0
        strategy.close("L", comment="eod-flat")
    if strategy.position_size < 0
        strategy.close("S", comment="eod-flat")

// ----------------------------------------------------------------------------------------
// Visualization - Killzone Levels (like ICT Killzones indicator)
// ----------------------------------------------------------------------------------------
// Max sessions to display
var int maxSessions = 30

// Arrays for storing multiple sessions
var array<line>  kzHighLines  = array.new_line()
var array<line>  kzLowLines   = array.new_line()
var array<label> kzHighLabels = array.new_label()
var array<label> kzLowLabels  = array.new_label()
var array<bool>  kzHighValids = array.new_bool()
var array<bool>  kzLowValids  = array.new_bool()

// Transparent color for label background
var transparent = color.new(color.white, 100)

// Helper function to add new killzone visuals
addKzVisuals(int highBar, float highPrice, int lowBar, float lowPrice, string source, bool highAlreadySwept, bool lowAlreadySwept) =>
    // Create high line starting from the bar where the high was made
    hiLine = line.new(highBar, highPrice, bar_index, highPrice, xloc=xloc.bar_index,
         style=line.style_solid, color=color.red, width=1)
    hiLabel = label.new(highBar, highPrice, str.upper(source) + ".H",
         xloc=xloc.bar_index, style=label.style_label_down, color=transparent, textcolor=color.red, size=size.small)

    // Create low line starting from the bar where the low was made
    loLine = line.new(lowBar, lowPrice, bar_index, lowPrice, xloc=xloc.bar_index,
         style=line.style_solid, color=color.green, width=1)
    loLabel = label.new(lowBar, lowPrice, str.upper(source) + ".L",
         xloc=xloc.bar_index, style=label.style_label_up, color=transparent, textcolor=color.green, size=size.small)

    // Add to arrays (at beginning) - mark as invalid if already swept
    array.unshift(kzHighLines, hiLine)
    array.unshift(kzLowLines, loLine)
    array.unshift(kzHighLabels, hiLabel)
    array.unshift(kzLowLabels, loLabel)
    array.unshift(kzHighValids, not highAlreadySwept)
    array.unshift(kzLowValids, not lowAlreadySwept)

    // Remove old entries if exceeding max
    if array.size(kzHighLines) > maxSessions
        line.delete(array.pop(kzHighLines))
        line.delete(array.pop(kzLowLines))
        label.delete(array.pop(kzHighLabels))
        label.delete(array.pop(kzLowLabels))
        array.pop(kzHighValids)
        array.pop(kzLowValids)

// Detect when Asia session ends and create lines
if asiaJustEnded and not na(asiaHigh) and not na(asiaLow)
    addKzVisuals(asiaHighBar, asiaHigh, asiaLowBar, asiaLow, "asia", asiaHighSwept, asiaLowSwept)

// Detect when London session ends and create lines
if londonJustEnded and not na(londonHigh) and not na(londonLow)
    addKzVisuals(londonHighBar, londonHigh, londonLowBar, londonLow, "ldn", londonHighSwept, londonLowSwept)

// Create PDH/PDL lines on new day when levels are locked
if newDay and not na(pdh) and not na(pdl)
    addKzVisuals(pdhBar, pdh, pdlBar, pdl, "pd", pdhSwept, pdlSwept)

// Create 1H swing high line when new pivot high is detected
if newSwingHighDetected and not na(swingHigh1H) and not na(swingHigh1HBar)
    hiLine = line.new(swingHigh1HBar, swingHigh1H, bar_index, swingHigh1H, xloc=xloc.bar_index,
         style=line.style_solid, color=color.orange, width=1)
    hiLabel = label.new(swingHigh1HBar, swingHigh1H, "1H.H",
         xloc=xloc.bar_index, style=label.style_label_down, color=transparent, textcolor=color.orange, size=size.small)
    array.unshift(kzHighLines, hiLine)
    array.unshift(kzHighLabels, hiLabel)
    array.unshift(kzHighValids, true)
    if array.size(kzHighLines) > maxSessions
        line.delete(array.pop(kzHighLines))
        label.delete(array.pop(kzHighLabels))
        array.pop(kzHighValids)

// Create 1H swing low line when new pivot low is detected
if newSwingLowDetected and not na(swingLow1H) and not na(swingLow1HBar)
    loLine = line.new(swingLow1HBar, swingLow1H, bar_index, swingLow1H, xloc=xloc.bar_index,
         style=line.style_solid, color=color.blue, width=1)
    loLabel = label.new(swingLow1HBar, swingLow1H, "1H.L",
         xloc=xloc.bar_index, style=label.style_label_up, color=transparent, textcolor=color.blue, size=size.small)
    array.unshift(kzLowLines, loLine)
    array.unshift(kzLowLabels, loLabel)
    array.unshift(kzLowValids, true)
    if array.size(kzLowLines) > maxSessions
        line.delete(array.pop(kzLowLines))
        label.delete(array.pop(kzLowLabels))
        array.pop(kzLowValids)

// Update all lines - extend valid ones, check for mitigation
// Process high lines
if array.size(kzHighLines) > 0
    for i = 0 to array.size(kzHighLines) - 1
        if array.get(kzHighValids, i)
            hiLine = array.get(kzHighLines, i)
            hiPrice = line.get_y1(hiLine)
            // Check if traded through
            if high > hiPrice
                array.set(kzHighValids, i, false)
                // Set line end to the bar that traded through it
                line.set_x2(hiLine, bar_index)
            else
                line.set_x2(hiLine, bar_index)

// Process low lines separately (arrays may have different sizes due to independent 1H swing detection)
if array.size(kzLowLines) > 0
    for i = 0 to array.size(kzLowLines) - 1
        if array.get(kzLowValids, i)
            loLine = array.get(kzLowLines, i)
            loPrice = line.get_y1(loLine)
            // Check if traded through
            if low < loPrice
                array.set(kzLowValids, i, false)
                // Set line end to the bar that traded through it
                line.set_x2(loLine, bar_index)
            else
                line.set_x2(loLine, bar_index)
