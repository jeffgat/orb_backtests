//@version=6
strategy(
     title              = "ORB V4",
     overlay            = true,
     initial_capital    = 100000,
     pyramiding         = 0,
     margin_long        = 0,
     margin_short       = 0,
     commission_type    = strategy.commission.cash_per_contract,
     commission_value   = 0.05,
     process_orders_on_close = true,
     use_bar_magnifier  = true,
     fill_orders_on_standard_ohlc = false
)

// ----------------------------------------------------------------------------------------
// Inputs
// ----------------------------------------------------------------------------------------
riskUsd      = input.float(1000, "Risk per trade ($)", step=50)
rr           = input.float(2.5, "Reward/Risk", step=0.25)
tp1Ratio     = input.float(0.5, "Partial TP & BE Level (0.5 = 50% of target)", step=0.1, minval=0.1, maxval=0.9)

sessionRTH   = input.session("0930-1600", "Regular session (ny time)")
orbSession   = input.session("0930-0945", "Opening range window (ny time)")
entryWindow  = input.session("0930-1300", "Entry window (no entries after, ny time)")
flatWindow   = input.session("1550-1600", "Flat window (close at 15:50, ny time)")

// If your CFD needs integer sizing, keep these at 1.
// If you need micro sizing, set minQty=0.1 and qtyStep=0.1, etc.
minQty       = input.float(1.0, "Min Qty", step=0.1)
qtyStep      = input.float(1.0, "Qty Step", step=0.1)

// FVG minimum gap size filter (gap must be at least this size to be valid)
minGapPoints = input.float(10.0, "Min Gap (points)", step=1.0, tooltip="Minimum gap size in points")
minGapTicks  = input.int(40, "Min Gap (ticks)", step=5, tooltip="Minimum gap size in ticks - uses whichever is larger")

// Breakeven offset (ticks above/below entry to cover commission and ensure small profit)
beOffsetTicks = input.int(4, "BE Offset (ticks)", step=1, tooltip="Ticks above entry for BE stop to cover commission")

// ----------------------------------------------------------------------------------------
// Safety: intended for 5m charts
// ----------------------------------------------------------------------------------------
is5m = timeframe.isintraday and timeframe.multiplier == 5
barClosed = barstate.isconfirmed

// ----------------------------------------------------------------------------------------
// Session filters (exchange-time consistent)
// ----------------------------------------------------------------------------------------
inRTH      = not na(time(timeframe.period, sessionRTH, "America/New_York"))
inORB      = not na(time(timeframe.period, orbSession, "America/New_York"))
inEntryWin = not na(time(timeframe.period, entryWindow, "America/New_York"))
inFlatWin  = not na(time(timeframe.period, flatWindow, "America/New_York"))

afterCutoff = inRTH and not inEntryWin

// new trading day
newDay = ta.change(time("D")) != 0

// ----------------------------------------------------------------------------------------
// exclude specific problematic dates
// ----------------------------------------------------------------------------------------
currentMonth = month(time, "America/New_York")
currentDay   = dayofmonth(time, "America/New_York")
currentYear  = year(time, "America/New_York")

// dec 18, 2024 - exclude due to data issue
isExcludedDate = currentYear == 2024 and currentMonth == 12 and currentDay == 18

// ----------------------------------------------------------------------------------------
// ORB state
// ----------------------------------------------------------------------------------------
var float orbHigh  = na
var float orbLow   = na
var bool  orbReady = false

// 1 FILLED trade per day
var bool hasTradedToday = false
var int closedTradesAtDayStart = 0

// Persistent setup states (so retest fills are not missed)
var bool  longSetupActive  = false
var bool  shortSetupActive = false
var bool  longFirstFvgFound  = false
var bool  shortFirstFvgFound = false

// store anchored risk params from the breakout/breakdown candle
var float longStopStored   = na
var float longTargetStored = na
var float longHalfwayStored = na
var float longEntryStored  = na
var float longQtyStored    = na
var float longHalfQty      = na
var bool  longBEActive      = false
var bool  longSingleContract = false  // true when qty == minQty (skip TP1, go straight to BE + TP2)
var float longFilledEntry  = na  // actual fill price for hard stop calc

var float shortStopStored   = na
var float shortTargetStored = na
var float shortHalfwayStored = na
var float shortEntryStored  = na
var float shortQtyStored    = na
var float shortHalfQty      = na
var bool  shortBEActive      = false
var bool  shortSingleContract = false  // true when qty == minQty (skip TP1, go straight to BE + TP2)
var float shortFilledEntry = na  // actual fill price for hard stop calc

// track bar index when setup was armed (to require retest on future bar)
var int longSetupBar  = na
var int shortSetupBar = na

// ----------------------------------------------------------------------------------------
// Reset on new day
// ----------------------------------------------------------------------------------------
if newDay
    orbHigh := na
    orbLow  := na
    orbReady := false
    hasTradedToday := false
    closedTradesAtDayStart := strategy.closedtrades

    longSetupActive := false
    shortSetupActive := false
    longFirstFvgFound := false
    shortFirstFvgFound := false
    longStopStored := na
    longTargetStored := na
    longHalfwayStored := na
    longEntryStored := na
    longQtyStored := na
    longHalfQty := na
    longBEActive := false
    longSingleContract := false
    longFilledEntry := na
    shortStopStored := na
    shortTargetStored := na
    shortHalfwayStored := na
    shortEntryStored := na
    shortQtyStored := na
    shortHalfQty := na
    shortBEActive := false
    shortSingleContract := false
    shortFilledEntry := na
    longSetupBar := na
    shortSetupBar := na

    strategy.cancel("L")
    strategy.cancel("S")

// ----------------------------------------------------------------------------------------
// Detect any trade occurred today (robust, incl. same-bar round trips)
// ----------------------------------------------------------------------------------------
tradeHappenedToday =
     (strategy.opentrades > 0) or (strategy.closedtrades > closedTradesAtDayStart)

if tradeHappenedToday and not hasTradedToday
    hasTradedToday := true
    longSetupActive := false
    shortSetupActive := false
    longFirstFvgFound := true
    shortFirstFvgFound := true
    longEntryStored := na
    shortEntryStored := na
    strategy.cancel("L")
    strategy.cancel("S")

// ----------------------------------------------------------------------------------------
// Build ORB (09:30â€“09:45)
// ----------------------------------------------------------------------------------------
if inORB and inRTH and is5m
    orbHigh := na(orbHigh) ? high : math.max(orbHigh, high)
    orbLow  := na(orbLow)  ? low  : math.min(orbLow, low)

// Lock ORB after window ends
if not inORB and inRTH and is5m and not orbReady and not na(orbHigh) and not na(orbLow)
    orbReady := true

// ----------------------------------------------------------------------------------------
// minimum fvg size requirement (configurable via inputs)
// ----------------------------------------------------------------------------------------
minGap = math.max(minGapPoints, minGapTicks * syminfo.mintick)

// fvg detection using 3-candle pattern (matching test.pine logic):
// - bar [2] = "before" candle
// - bar [1] = impulse candle (creates the gap)
// - bar [0] = "after" candle (confirms gap still exists) - current closed bar
// bullish fvg: high[2] < low (gap between before candle high and after candle low)
// bearish fvg: low[2] > high (gap between before candle low and after candle high)
longFvgTop    = low       // top of the gap (after candle low)
longFvgBottom = high[2]   // bottom of the gap (before candle high)
shortFvgTop   = low[2]    // top of the gap (before candle low)
shortFvgBottom = high     // bottom of the gap (after candle high)
longGapSize  = longFvgTop - longFvgBottom
shortGapSize = shortFvgTop - shortFvgBottom

// full fvg validation (matching test.pine):
// bullish: high[2] < low AND high[2] < high[1] AND low[2] < low
// bearish: low[2] > high AND low[2] > low[1] AND high[2] > high
longFVG  = high[2] < low and high[2] < high[1] and low[2] < low and longFvgTop > orbHigh and longGapSize >= minGap
shortFVG = low[2] > high and low[2] > low[1] and high[2] > high and shortFvgBottom < orbLow and shortGapSize >= minGap

// BE offset calculation (beOffsetTicks is configurable via inputs)
beOffset = beOffsetTicks * syminfo.mintick

// ----------------------------------------------------------------------------------------
// qty rounding helpers
// ----------------------------------------------------------------------------------------
floorToStep(x, step) =>
    step <= 0 ? x : math.floor(x / step) * step

// ----------------------------------------------------------------------------------------
// Activate setup on breakout/breakdown candle (store anchored SL/TP/Qty)
// Only if:
// - within entry window
// - no trade filled yet today
// - flat/no position
// - no other setup active
// --------------------
canArmSetup =
     is5m and barClosed and inRTH and inEntryWin and orbReady and not hasTradedToday and not isExcludedDate and strategy.position_size == 0 and not (longSetupActive or shortSetupActive)

// long setup arm
// fvg validity already checks longFvgTop > orbHigh, so no separate break check needed
if canArmSetup and not longFirstFvgFound and longFVG
    // sl = low of the "before" candle (bar [2]) for wider stop
    rawStop = low[2]
    entry   = longFvgTop  // enter at top of fvg (after candle low)
    stop    = math.min(rawStop, entry - syminfo.mintick)  // enforce valid side
    riskPts = entry - stop

    if riskPts > 0
        qtyRaw = riskUsd / (riskPts * syminfo.pointvalue)
        qty    = floorToStep(qtyRaw, qtyStep)
        // check if single contract (can't split for partial TP)
        isSingleContract = qty <= minQty
        halfQty = isSingleContract ? qty : floorToStep(qty / 2, qtyStep)
        halfQty := math.max(halfQty, minQty)

        if qty >= minQty
            longStopStored   := stop
            longTargetStored := entry + rr * riskPts
            longHalfwayStored := entry + (rr * riskPts * tp1Ratio)
            longEntryStored  := entry
            longQtyStored    := qty
            longHalfQty      := halfQty
            longSingleContract := isSingleContract
            longSetupActive  := true
            longFirstFvgFound := true
            longSetupBar     := bar_index

// short setup arm
// fvg validity already checks shortFvgBottom < orbLow, so no separate break check needed
if canArmSetup and not shortFirstFvgFound and shortFVG
    // sl = high of the "before" candle (bar [2]) for wider stop
    rawStop = high[2]
    entry   = shortFvgBottom  // enter at bottom of fvg (after candle high)
    stop    = math.max(rawStop, entry + syminfo.mintick) // enforce valid side
    riskPts = stop - entry

    if riskPts > 0
        qtyRaw = riskUsd / (riskPts * syminfo.pointvalue)
        qty    = floorToStep(qtyRaw, qtyStep)
        // check if single contract (can't split for partial TP)
        isSingleContract = qty <= minQty
        halfQty = isSingleContract ? qty : floorToStep(qty / 2, qtyStep)
        halfQty := math.max(halfQty, minQty)

        if qty >= minQty
            shortStopStored   := stop
            shortTargetStored := entry - rr * riskPts
            shortHalfwayStored := entry - (rr * riskPts * tp1Ratio)
            shortEntryStored  := entry
            shortQtyStored    := qty
            shortHalfQty      := halfQty
            shortSingleContract := isSingleContract
            shortSetupActive  := true
            shortFirstFvgFound := true
            shortSetupBar     := bar_index

// ----------------------------------------------------------------------------------------
// track actual entry fill price for hard stop calculation
// ----------------------------------------------------------------------------------------
if strategy.position_size > 0 and na(longFilledEntry)
    longFilledEntry := strategy.opentrades.entry_price(0)
if strategy.position_size < 0 and na(shortFilledEntry)
    shortFilledEntry := strategy.opentrades.entry_price(0)

// ----------------------------------------------------------------------------------------
// update breakeven state if halfway point is reached
// for single contracts: activate BE when price reaches tp1 level (no partial exit)
// for multi contracts: also activate when position size drops (partial TP1 fill occurred)
// note: requires longFilledEntry to be set to distinguish partial TP1 from partial entry fill
// ----------------------------------------------------------------------------------------
if strategy.position_size > 0
    if longSingleContract
        // single contract: BE activates when price reaches tp1 level
        if not na(longHalfwayStored) and high >= longHalfwayStored
            longBEActive := true
    else
        // multi contract: BE activates when price reaches tp1 level OR partial TP1 fill occurred
        // check longFilledEntry is set to ensure full entry filled before detecting position reduction as TP1
        positionReduced = strategy.position_size < longQtyStored and longQtyStored > 0 and not na(longFilledEntry)
        if (not na(longHalfwayStored) and high >= longHalfwayStored) or positionReduced
            longBEActive := true
if strategy.position_size < 0
    if shortSingleContract
        // single contract: BE activates when price reaches tp1 level
        if not na(shortHalfwayStored) and low <= shortHalfwayStored
            shortBEActive := true
    else
        // multi contract: BE activates when price reaches tp1 level OR partial TP1 fill occurred
        // check shortFilledEntry is set to ensure full entry filled before detecting position reduction as TP1
        positionReduced = math.abs(strategy.position_size) < shortQtyStored and shortQtyStored > 0 and not na(shortFilledEntry)
        if (not na(shortHalfwayStored) and low <= shortHalfwayStored) or positionReduced
            shortBEActive := true

// ----------------------------------------------------------------------------------------
// entry orders (only before trade filled, and only AFTER setup bar for true retest)
// ----------------------------------------------------------------------------------------
if is5m and inRTH and inEntryWin and not hasTradedToday
    // only place entry order on bars AFTER the FVG formed (require price to revisit)
    if longSetupActive and bar_index > longSetupBar
        strategy.entry("L", strategy.long, qty=longQtyStored, limit=longEntryStored)
    if shortSetupActive and bar_index > shortSetupBar
        strategy.entry("S", strategy.short, qty=shortQtyStored, limit=shortEntryStored)

// ----------------------------------------------------------------------------------------
// exit orders - unified approach with hard dollar stop
// single contract: skip TP1, use BE stop after tp1 level reached, exit at TP2
// multi contract: partial exit at TP1, then BE stop for remainder
// ----------------------------------------------------------------------------------------
if strategy.position_size > 0
    // use actual fill price for BE stop, +offset to cover commission and ensure profit
    beStopPrice = (not na(longFilledEntry) ? longFilledEntry : longEntryStored) + beOffset
    finalStop = longBEActive ? beStopPrice : longStopStored

    if longSingleContract
        // single contract: no partial TP, just BE stop after tp1 level + full TP2
        strategy.exit("L-F", from_entry="L", stop=finalStop, limit=longTargetStored, comment_loss=longBEActive ? "l-be" : "l-sl", comment_profit="l-tp2")
    else
        // multi contract: partial exit at TP1, then BE for remainder
        strategy.exit("L-P", from_entry="L", qty=longHalfQty, stop=longStopStored, limit=longHalfwayStored, comment_loss="l-sl", comment_profit="l-tp1")
        strategy.exit("L-F", from_entry="L", stop=finalStop, limit=longTargetStored, comment_loss=longBEActive ? "l-be" : "l-sl", comment_profit="l-tp2")

if strategy.position_size < 0
    // use actual fill price for BE stop, -offset to cover commission and ensure profit
    beStopPrice = (not na(shortFilledEntry) ? shortFilledEntry : shortEntryStored) - beOffset
    finalStop = shortBEActive ? beStopPrice : shortStopStored

    if shortSingleContract
        // single contract: no partial TP, just BE stop after tp1 level + full TP2
        strategy.exit("S-F", from_entry="S", stop=finalStop, limit=shortTargetStored, comment_loss=shortBEActive ? "s-be" : "s-sl", comment_profit="s-tp2")
    else
        // multi contract: partial exit at TP1, then BE for remainder
        strategy.exit("S-P", from_entry="S", qty=shortHalfQty, stop=shortStopStored, limit=shortHalfwayStored, comment_loss="s-sl", comment_profit="s-tp1")
        strategy.exit("S-F", from_entry="S", stop=finalStop, limit=shortTargetStored, comment_loss=shortBEActive ? "s-be" : "s-sl", comment_profit="s-tp2")

// ----------------------------------------------------------------------------------------
// Cancel pending orders after cutoff and after RTH
// ----------------------------------------------------------------------------------------
if afterCutoff
    strategy.cancel("L")
    strategy.cancel("S")
    longSetupActive := false
    shortSetupActive := false
    longEntryStored := na
    shortEntryStored := na
    longSetupBar := na
    shortSetupBar := na

if not inRTH
    strategy.cancel("L")
    strategy.cancel("S")
    longSetupActive := false
    shortSetupActive := false
    longEntryStored := na
    shortEntryStored := na
    longSetupBar := na
    shortSetupBar := na

// ----------------------------------------------------------------------------------------
// flat at 15:50 - close any remaining position at market
// this should rarely happen since stops/targets should have filled
// ----------------------------------------------------------------------------------------
if inFlatWin and strategy.position_size != 0
    if strategy.position_size > 0
        strategy.close("L", comment="eod-flat")
    if strategy.position_size < 0
        strategy.close("S", comment="eod-flat")

// ----------------------------------------------------------------------------------------
// Visuals
// ----------------------------------------------------------------------------------------
// Plot ORB lines only until 12:00 (exchange time)
plotORB = inRTH and inEntryWin
plot(plotORB ? orbHigh : na, "ORB High", style=plot.style_linebr, linewidth=2, color=color.new(#18b79c, 0))
plot(plotORB ? orbLow  : na, "ORB Low",  style=plot.style_linebr, linewidth=2, color=color.new(#5d606b, 0))