//@version=6
strategy(
     title              = "ORB V3",
     overlay            = true,
     initial_capital    = 100000,
     pyramiding         = 0,
     margin_long        = 0,
     margin_short       = 0,
     commission_type    = strategy.commission.cash_per_contract,
     commission_value   = 0.05,
     process_orders_on_close = true,
     use_bar_magnifier  = true,
     fill_orders_on_standard_ohlc = false
)

// ----------------------------------------------------------------------------------------
// Inputs
// ----------------------------------------------------------------------------------------
riskUsd      = input.float(1000, "Risk per trade ($)", step=50)
rr           = input.float(2.0, "Reward/Risk", step=0.25)
tp1Ratio     = input.float(0.5, "Partial TP & BE Level (0.5 = 50% of target)", step=0.1, minval=0.1, maxval=0.9)

sessionRTH   = input.session("0930-1600", "Regular session (ny time)")
orbSession   = input.session("0930-0945", "Opening range window (ny time)")
entryWindow  = input.session("0930-1200", "Entry window (no entries after, ny time)")
flatWindow   = input.session("1550-1600", "Flat window (close at 15:50, ny time)")

// If your CFD needs integer sizing, keep these at 1.
// If you need micro sizing, set minQty=0.1 and qtyStep=0.1, etc.
minQty       = input.float(1.0, "Min Qty", step=0.1)
qtyStep      = input.float(1.0, "Qty Step", step=0.1)

// ----------------------------------------------------------------------------------------
// Safety: intended for 5m charts
// ----------------------------------------------------------------------------------------
is5m = timeframe.isintraday and timeframe.multiplier == 5
barClosed = barstate.isconfirmed

// ----------------------------------------------------------------------------------------
// Session filters (exchange-time consistent)
// ----------------------------------------------------------------------------------------
inRTH      = not na(time(timeframe.period, sessionRTH, "America/New_York"))
inORB      = not na(time(timeframe.period, orbSession, "America/New_York"))
inEntryWin = not na(time(timeframe.period, entryWindow, "America/New_York"))
inFlatWin  = not na(time(timeframe.period, flatWindow, "America/New_York"))

afterCutoff = inRTH and not inEntryWin

// new trading day
newDay = ta.change(time("D")) != 0

// ----------------------------------------------------------------------------------------
// exclude specific problematic dates
// ----------------------------------------------------------------------------------------
currentMonth = month(time, "America/New_York")
currentDay   = dayofmonth(time, "America/New_York")
currentYear  = year(time, "America/New_York")

// dec 18, 2024 - exclude due to data issue
isExcludedDate = currentYear == 2024 and currentMonth == 12 and currentDay == 18

// ----------------------------------------------------------------------------------------
// ORB state
// ----------------------------------------------------------------------------------------
var float orbHigh  = na
var float orbLow   = na
var bool  orbReady = false

// 1 FILLED trade per day
var bool hasTradedToday = false
var int closedTradesAtDayStart = 0

// Persistent setup states (so retest fills are not missed)
var bool  longSetupActive  = false
var bool  shortSetupActive = false
var bool  longFirstFvgFound  = false
var bool  shortFirstFvgFound = false

// store anchored risk params from the breakout/breakdown candle
var float longStopStored   = na
var float longTargetStored = na
var float longHalfwayStored = na
var float longEntryStored  = na
var float longQtyStored    = na
var float longHalfQty      = na
var bool  longBEActive      = false
var float longFilledEntry  = na  // actual fill price for hard stop calc

var float shortStopStored   = na
var float shortTargetStored = na
var float shortHalfwayStored = na
var float shortEntryStored  = na
var float shortQtyStored    = na
var float shortHalfQty      = na
var bool  shortBEActive      = false
var float shortFilledEntry = na  // actual fill price for hard stop calc

// track bar index when setup was armed (to require retest on future bar)
var int longSetupBar  = na
var int shortSetupBar = na

// ----------------------------------------------------------------------------------------
// Reset on new day
// ----------------------------------------------------------------------------------------
if newDay
    orbHigh := na
    orbLow  := na
    orbReady := false
    hasTradedToday := false
    closedTradesAtDayStart := strategy.closedtrades

    longSetupActive := false
    shortSetupActive := false
    longFirstFvgFound := false
    shortFirstFvgFound := false
    longStopStored := na
    longTargetStored := na
    longHalfwayStored := na
    longEntryStored := na
    longQtyStored := na
    longHalfQty := na
    longBEActive := false
    longFilledEntry := na
    shortStopStored := na
    shortTargetStored := na
    shortHalfwayStored := na
    shortEntryStored := na
    shortQtyStored := na
    shortHalfQty := na
    shortBEActive := false
    shortFilledEntry := na
    longSetupBar := na
    shortSetupBar := na

    strategy.cancel("L")
    strategy.cancel("S")

// ----------------------------------------------------------------------------------------
// Detect any trade occurred today (robust, incl. same-bar round trips)
// ----------------------------------------------------------------------------------------
tradeHappenedToday =
     (strategy.opentrades > 0) or (strategy.closedtrades > closedTradesAtDayStart)

if tradeHappenedToday and not hasTradedToday
    hasTradedToday := true
    longSetupActive := false
    shortSetupActive := false
    longFirstFvgFound := true
    shortFirstFvgFound := true
    longEntryStored := na
    shortEntryStored := na
    strategy.cancel("L")
    strategy.cancel("S")

// ----------------------------------------------------------------------------------------
// Build ORB (09:30â€“09:45)
// ----------------------------------------------------------------------------------------
if inORB and inRTH and is5m
    orbHigh := na(orbHigh) ? high : math.max(orbHigh, high)
    orbLow  := na(orbLow)  ? low  : math.min(orbLow, low)

// Lock ORB after window ends
if not inORB and inRTH and is5m and not orbReady and not na(orbHigh) and not na(orbLow)
    orbReady := true

// ----------------------------------------------------------------------------------------
// Breakout detection: first candle that closes outside the ORB
// ----------------------------------------------------------------------------------------
// Long breakout: candle closes above ORB high
longBreakout = close > orbHigh

// Short breakdown: candle closes below ORB low
shortBreakdown = close < orbLow

// ----------------------------------------------------------------------------------------
// qty rounding helpers
// ----------------------------------------------------------------------------------------
floorToStep(x, step) =>
    step <= 0 ? x : math.floor(x / step) * step

// ----------------------------------------------------------------------------------------
// Market entry on first breakout candle (store anchored SL/TP/Qty and enter immediately)
// Only if:
// - within entry window
// - no trade filled yet today
// - flat/no position
// --------------------
canEnter =
     is5m and barClosed and inRTH and inEntryWin and orbReady and not hasTradedToday and not isExcludedDate and strategy.position_size == 0

// long market entry on breakout
// enter at market (close), stop at low of the breakout candle
if canEnter and not longFirstFvgFound and longBreakout
    entry   = close  // market entry at candle close
    stop    = math.min(low, entry - syminfo.mintick)  // stop at low of breakout candle
    riskPts = entry - stop

    if riskPts > 0
        qtyRaw = riskUsd / (riskPts * syminfo.pointvalue)
        qty    = floorToStep(qtyRaw, qtyStep)
        halfQty = floorToStep(qty / 2, qtyStep)
        halfQty := math.max(halfQty, minQty)  // ensure at least minQty for partial

        if qty >= minQty
            longStopStored   := stop
            longTargetStored := entry + rr * riskPts
            longHalfwayStored := entry + (rr * riskPts * tp1Ratio)
            longEntryStored  := entry
            longQtyStored    := qty
            longHalfQty      := halfQty
            longFirstFvgFound := true  // prevent additional entries
            strategy.entry("L", strategy.long, qty=qty)

// short market entry on breakdown
// enter at market (close), stop at high of the breakdown candle
if canEnter and not shortFirstFvgFound and shortBreakdown
    entry   = close  // market entry at candle close
    stop    = math.max(high, entry + syminfo.mintick)  // stop at high of breakdown candle
    riskPts = stop - entry

    if riskPts > 0
        qtyRaw = riskUsd / (riskPts * syminfo.pointvalue)
        qty    = floorToStep(qtyRaw, qtyStep)
        halfQty = floorToStep(qty / 2, qtyStep)
        halfQty := math.max(halfQty, minQty)  // ensure at least minQty for partial

        if qty >= minQty
            shortStopStored   := stop
            shortTargetStored := entry - rr * riskPts
            shortHalfwayStored := entry - (rr * riskPts * tp1Ratio)
            shortEntryStored  := entry
            shortQtyStored    := qty
            shortHalfQty      := halfQty
            shortFirstFvgFound := true  // prevent additional entries
            strategy.entry("S", strategy.short, qty=qty)

// ----------------------------------------------------------------------------------------
// track actual entry fill price for hard stop calculation
// ----------------------------------------------------------------------------------------
if strategy.position_size > 0 and na(longFilledEntry)
    longFilledEntry := strategy.opentrades.entry_price(0)
if strategy.position_size < 0 and na(shortFilledEntry)
    shortFilledEntry := strategy.opentrades.entry_price(0)

// ----------------------------------------------------------------------------------------
// update breakeven state if halfway point is reached
// also detect if partial exit has occurred (position size reduced from full qty)
// ----------------------------------------------------------------------------------------
if strategy.position_size > 0
    // be activates when price reaches tp1 level OR when position size drops (partial fill)
    if high >= longHalfwayStored or (strategy.position_size < longQtyStored and longQtyStored > 0)
        longBEActive := true
if strategy.position_size < 0
    // be activates when price reaches tp1 level OR when position size drops (partial fill)
    if low <= shortHalfwayStored or (math.abs(strategy.position_size) < shortQtyStored and shortQtyStored > 0)
        shortBEActive := true


// ----------------------------------------------------------------------------------------
// exit orders - unified approach with hard dollar stop
// calculate effective stop based on position size to guarantee max loss = riskUsd
// ----------------------------------------------------------------------------------------
if strategy.position_size > 0
    // use actual fill price for BE stop (not the limit order price)
    beStopPrice = not na(longFilledEntry) ? longFilledEntry : longEntryStored
    // for partial exit before tp1, use original stop
    strategy.exit("L-P", from_entry="L", qty=longHalfQty, stop=longStopStored, limit=longHalfwayStored, comment_loss="l-sl", comment_profit="l-tp1")
    // for remaining position, use BE stop if tp1 was hit, otherwise original stop
    finalStop = longBEActive ? beStopPrice : longStopStored
    strategy.exit("L-F", from_entry="L", stop=finalStop, limit=longTargetStored, comment_loss="l-be", comment_profit="l-tp2")

if strategy.position_size < 0
    // use actual fill price for BE stop (not the limit order price)
    beStopPrice = not na(shortFilledEntry) ? shortFilledEntry : shortEntryStored
    // for partial exit before tp1, use original stop
    strategy.exit("S-P", from_entry="S", qty=shortHalfQty, stop=shortStopStored, limit=shortHalfwayStored, comment_loss="s-sl", comment_profit="s-tp1")
    // for remaining position, use BE stop if tp1 was hit, otherwise original stop
    finalStop = shortBEActive ? beStopPrice : shortStopStored
    strategy.exit("S-F", from_entry="S", stop=finalStop, limit=shortTargetStored, comment_loss="s-be", comment_profit="s-tp2")


// ----------------------------------------------------------------------------------------
// flat at 15:50 - close any remaining position at market
// this should rarely happen since stops/targets should have filled
// ----------------------------------------------------------------------------------------
if inFlatWin and strategy.position_size != 0
    if strategy.position_size > 0
        strategy.close("L", comment="eod-flat")
    if strategy.position_size < 0
        strategy.close("S", comment="eod-flat")

// ----------------------------------------------------------------------------------------
// Visuals
// ----------------------------------------------------------------------------------------
// Plot ORB lines only until 12:00 (exchange time)
plotORB = inRTH and inEntryWin
plot(plotORB ? orbHigh : na, "ORB High", style=plot.style_linebr, linewidth=2, color=color.new(#18b79c, 0))
plot(plotORB ? orbLow  : na, "ORB Low",  style=plot.style_linebr, linewidth=2, color=color.new(#5d606b, 0))