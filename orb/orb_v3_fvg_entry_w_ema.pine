//@version=6
strategy(
     title              = "ORB V3",
     overlay            = true,
     initial_capital    = 100000,
     pyramiding         = 0,
     margin_long        = 0,
     margin_short       = 0,
     commission_type    = strategy.commission.cash_per_contract,
     commission_value   = 0.05,
     process_orders_on_close = true,
     use_bar_magnifier  = true,
     fill_orders_on_standard_ohlc = false
)

// ----------------------------------------------------------------------------------------
// Inputs
// ----------------------------------------------------------------------------------------
riskUsd      = input.float(1000, "Risk per trade ($)", step=50)
rr           = input.float(2.0, "Reward/Risk", step=0.25)
tp1Ratio     = input.float(0.5, "Partial TP & BE Level (0.5 = 50% of target)", step=0.1, minval=0.1, maxval=0.9)

sessionRTH   = input.session("0930-1600", "Regular session (ny time)")
orbSession   = input.session("0930-0945", "Opening range window (ny time)")
entryWindow  = input.session("0930-1200", "Entry window (no entries after, ny time)")
flatWindow   = input.session("1550-1600", "Flat window (close at 15:50, ny time)")

// If your CFD needs integer sizing, keep these at 1.
// If you need micro sizing, set minQty=0.1 and qtyStep=0.1, etc.
minQty       = input.float(1.0, "Min Qty", step=0.1)
qtyStep      = input.float(1.0, "Qty Step", step=0.1)

// EMA filter settings
emaLength    = input.int(200, "EMA Length")
emaTf        = input.timeframe("15", "EMA Timeframe")

// ----------------------------------------------------------------------------------------
// Safety: intended for 5m charts
// ----------------------------------------------------------------------------------------
is5m = timeframe.isintraday and timeframe.multiplier == 5
barClosed = barstate.isconfirmed

// ----------------------------------------------------------------------------------------
// Session filters (exchange-time consistent)
// ----------------------------------------------------------------------------------------
inRTH      = not na(time(timeframe.period, sessionRTH, "America/New_York"))
inORB      = not na(time(timeframe.period, orbSession, "America/New_York"))
inEntryWin = not na(time(timeframe.period, entryWindow, "America/New_York"))
inFlatWin  = not na(time(timeframe.period, flatWindow, "America/New_York"))

afterCutoff = inRTH and not inEntryWin

// new trading day
newDay = ta.change(time("D")) != 0

// ----------------------------------------------------------------------------------------
// 200 EMA on 15m timeframe (trend filter)
// ----------------------------------------------------------------------------------------
ema200_15m = request.security(syminfo.tickerid, emaTf, ta.ema(close, emaLength), barmerge.gaps_off, barmerge.lookahead_off)
priceAboveEma = close > ema200_15m
priceBelowEma = close < ema200_15m

// ----------------------------------------------------------------------------------------
// exclude specific problematic dates
// ----------------------------------------------------------------------------------------
currentMonth = month(time, "America/New_York")
currentDay   = dayofmonth(time, "America/New_York")
currentYear  = year(time, "America/New_York")

// dec 18, 2024 - exclude due to data issue
isExcludedDate = currentYear == 2024 and currentMonth == 12 and currentDay == 18

// ----------------------------------------------------------------------------------------
// ORB state
// ----------------------------------------------------------------------------------------
var float orbHigh  = na
var float orbLow   = na
var bool  orbReady = false

// 1 FILLED trade per day
var bool hasTradedToday = false
var int closedTradesAtDayStart = 0

// Persistent setup states (so retest fills are not missed)
var bool  longSetupActive  = false
var bool  shortSetupActive = false
var bool  longFirstFvgFound  = false
var bool  shortFirstFvgFound = false

// store anchored risk params from the breakout/breakdown candle
var float longStopStored   = na
var float longTargetStored = na
var float longHalfwayStored = na
var float longEntryStored  = na
var float longQtyStored    = na
var float longHalfQty      = na
var bool  longBEActive      = false
var float longFilledEntry  = na  // actual fill price for hard stop calc

var float shortStopStored   = na
var float shortTargetStored = na
var float shortHalfwayStored = na
var float shortEntryStored  = na
var float shortQtyStored    = na
var float shortHalfQty      = na
var bool  shortBEActive      = false
var float shortFilledEntry = na  // actual fill price for hard stop calc

// track bar index when setup was armed (to require retest on future bar)
var int longSetupBar  = na
var int shortSetupBar = na

// ----------------------------------------------------------------------------------------
// Reset on new day
// ----------------------------------------------------------------------------------------
if newDay
    orbHigh := na
    orbLow  := na
    orbReady := false
    hasTradedToday := false
    closedTradesAtDayStart := strategy.closedtrades

    longSetupActive := false
    shortSetupActive := false
    longFirstFvgFound := false
    shortFirstFvgFound := false
    longStopStored := na
    longTargetStored := na
    longHalfwayStored := na
    longEntryStored := na
    longQtyStored := na
    longHalfQty := na
    longBEActive := false
    longFilledEntry := na
    shortStopStored := na
    shortTargetStored := na
    shortHalfwayStored := na
    shortEntryStored := na
    shortQtyStored := na
    shortHalfQty := na
    shortBEActive := false
    shortFilledEntry := na
    longSetupBar := na
    shortSetupBar := na

    strategy.cancel("L")
    strategy.cancel("S")

// ----------------------------------------------------------------------------------------
// Detect any trade occurred today (robust, incl. same-bar round trips)
// ----------------------------------------------------------------------------------------
tradeHappenedToday =
     (strategy.opentrades > 0) or (strategy.closedtrades > closedTradesAtDayStart)

if tradeHappenedToday and not hasTradedToday
    hasTradedToday := true
    longSetupActive := false
    shortSetupActive := false
    longFirstFvgFound := true
    shortFirstFvgFound := true
    longEntryStored := na
    shortEntryStored := na
    strategy.cancel("L")
    strategy.cancel("S")

// ----------------------------------------------------------------------------------------
// Build ORB (09:30â€“09:45)
// ----------------------------------------------------------------------------------------
if inORB and inRTH and is5m
    orbHigh := na(orbHigh) ? high : math.max(orbHigh, high)
    orbLow  := na(orbLow)  ? low  : math.min(orbLow, low)

// Lock ORB after window ends
if not inORB and inRTH and is5m and not orbReady and not na(orbHigh) and not na(orbLow)
    orbReady := true

// ----------------------------------------------------------------------------------------
// minimum fvg size requirement:
// valid gap must be at least 5 points or 20 ticks (whichever is larger)
minGapPoints = 10.0
minGapTicks  = 40
minGap       = math.max(minGapPoints, minGapTicks * syminfo.mintick)

// fvg detection using 3-candle pattern (matching test.pine logic):
// - bar [2] = "before" candle
// - bar [1] = impulse candle (creates the gap)
// - bar [0] = "after" candle (confirms gap still exists) - current closed bar
// bullish fvg: high[2] < low (gap between before candle high and after candle low)
// bearish fvg: low[2] > high (gap between before candle low and after candle high)
longFvgTop    = low       // top of the gap (after candle low)
longFvgBottom = high[2]   // bottom of the gap (before candle high)
shortFvgTop   = low[2]    // top of the gap (before candle low)
shortFvgBottom = high     // bottom of the gap (after candle high)
longGapSize  = longFvgTop - longFvgBottom
shortGapSize = shortFvgTop - shortFvgBottom

// full fvg validation (matching test.pine):
// bullish: high[2] < low AND high[2] < high[1] AND low[2] < low
// bearish: low[2] > high AND low[2] > low[1] AND high[2] > high
longFVG  = high[2] < low and high[2] < high[1] and low[2] < low and longFvgTop > orbHigh and longGapSize >= minGap
shortFVG = low[2] > high and low[2] > low[1] and high[2] > high and shortFvgBottom < orbLow and shortGapSize >= minGap

// entry prices at fvg retest levels
longEntryPrice  = longEntryStored
shortEntryPrice = shortEntryStored

// ----------------------------------------------------------------------------------------
// qty rounding helpers
// ----------------------------------------------------------------------------------------
floorToStep(x, step) =>
    step <= 0 ? x : math.floor(x / step) * step

// ----------------------------------------------------------------------------------------
// Activate setup on breakout/breakdown candle (store anchored SL/TP/Qty)
// Only if:
// - within entry window
// - no trade filled yet today
// - flat/no position
// - no other setup active
// --------------------
canArmSetup =
     is5m and barClosed and inRTH and inEntryWin and orbReady and not hasTradedToday and not isExcludedDate and strategy.position_size == 0 and not (longSetupActive or shortSetupActive)

// long setup arm
// fvg validity already checks longFvgTop > orbHigh, so no separate break check needed
// only take longs when price is above the 200 EMA
if canArmSetup and not longFirstFvgFound and longFVG and priceAboveEma
    // sl = low of the impulse candle (bar [1]) that creates the FVG
    rawStop = low[1]
    entry   = longFvgTop  // enter at top of fvg (after candle low)
    stop    = math.min(rawStop, entry - syminfo.mintick)  // enforce valid side
    riskPts = entry - stop

    if riskPts > 0
        qtyRaw = riskUsd / (riskPts * syminfo.pointvalue)
        qty    = floorToStep(qtyRaw, qtyStep)
        halfQty = floorToStep(qty / 2, qtyStep)
        halfQty := math.max(halfQty, minQty)  // ensure at least minQty for partial

        if qty >= minQty
            longStopStored   := stop
            longTargetStored := entry + rr * riskPts
            longHalfwayStored := entry + (rr * riskPts * tp1Ratio)
            longEntryStored  := entry
            longQtyStored    := qty
            longHalfQty      := halfQty
            longSetupActive  := true
            longFirstFvgFound := true
            longSetupBar     := bar_index  // track when setup armed for retest requirement

// short setup arm
// fvg validity already checks shortFvgBottom < orbLow, so no separate break check needed
// only take shorts when price is below the 200 EMA
if canArmSetup and not shortFirstFvgFound and shortFVG and priceBelowEma
    // sl = high of the impulse candle (bar [1]) that creates the FVG
    rawStop = high[1]
    entry   = shortFvgBottom  // enter at bottom of fvg (after candle high)
    stop    = math.max(rawStop, entry + syminfo.mintick) // enforce valid side
    riskPts = stop - entry

    if riskPts > 0
        qtyRaw = riskUsd / (riskPts * syminfo.pointvalue)
        qty    = floorToStep(qtyRaw, qtyStep)
        halfQty = floorToStep(qty / 2, qtyStep)
        halfQty := math.max(halfQty, minQty)  // ensure at least minQty for partial

        if qty >= minQty
            shortStopStored   := stop
            shortTargetStored := entry - rr * riskPts
            shortHalfwayStored := entry - (rr * riskPts * tp1Ratio)
            shortEntryStored  := entry
            shortQtyStored    := qty
            shortHalfQty      := halfQty
            shortSetupActive  := true
            shortFirstFvgFound := true
            shortSetupBar     := bar_index  // track when setup armed for retest requirement

// ----------------------------------------------------------------------------------------
// track actual entry fill price for hard stop calculation
// ----------------------------------------------------------------------------------------
if strategy.position_size > 0 and na(longFilledEntry)
    longFilledEntry := strategy.opentrades.entry_price(0)
if strategy.position_size < 0 and na(shortFilledEntry)
    shortFilledEntry := strategy.opentrades.entry_price(0)

// ----------------------------------------------------------------------------------------
// update breakeven state if halfway point is reached
// also detect if partial exit has occurred (position size reduced from full qty)
// ----------------------------------------------------------------------------------------
if strategy.position_size > 0
    // be activates when price reaches tp1 level OR when position size drops (partial fill)
    if high >= longHalfwayStored or (strategy.position_size < longQtyStored and longQtyStored > 0)
        longBEActive := true
if strategy.position_size < 0
    // be activates when price reaches tp1 level OR when position size drops (partial fill)
    if low <= shortHalfwayStored or (math.abs(strategy.position_size) < shortQtyStored and shortQtyStored > 0)
        shortBEActive := true

// ----------------------------------------------------------------------------------------
// 30-minute timeout for unfilled limit orders (6 bars on 5m chart)
// ----------------------------------------------------------------------------------------
setupTimeoutBars = 12

if is5m and inRTH and not hasTradedToday and strategy.position_size == 0
    // cancel long setup if 30 minutes passed without fill
    if longSetupActive and bar_index >= longSetupBar + setupTimeoutBars
        strategy.cancel("L")
        longSetupActive := false
        longEntryStored := na
        longSetupBar := na
    // cancel short setup if 30 minutes passed without fill
    if shortSetupActive and bar_index >= shortSetupBar + setupTimeoutBars
        strategy.cancel("S")
        shortSetupActive := false
        shortEntryStored := na
        shortSetupBar := na

// ----------------------------------------------------------------------------------------
// entry orders (only before trade filled, and only AFTER setup bar for true retest)
// ----------------------------------------------------------------------------------------
if is5m and inRTH and inEntryWin and not hasTradedToday
    // only place entry order on bars AFTER the FVG formed (require price to revisit)
    if longSetupActive and bar_index > longSetupBar
        strategy.entry("L", strategy.long, qty=longQtyStored, limit=longEntryPrice)
    if shortSetupActive and bar_index > shortSetupBar
        strategy.entry("S", strategy.short, qty=shortQtyStored, limit=shortEntryPrice)

// ----------------------------------------------------------------------------------------
// exit orders - unified approach with hard dollar stop
// calculate effective stop based on position size to guarantee max loss = riskUsd
// ----------------------------------------------------------------------------------------
if strategy.position_size > 0
    // use actual fill price for BE stop (not the limit order price)
    beStopPrice = not na(longFilledEntry) ? longFilledEntry : longEntryStored
    // for partial exit before tp1, use original stop
    strategy.exit("L-P", from_entry="L", qty=longHalfQty, stop=longStopStored, limit=longHalfwayStored, comment_loss="l-sl", comment_profit="l-tp1")
    // for remaining position, use BE stop if tp1 was hit, otherwise original stop
    finalStop = longBEActive ? beStopPrice : longStopStored
    strategy.exit("L-F", from_entry="L", stop=finalStop, limit=longTargetStored, comment_loss="l-be", comment_profit="l-tp2")

if strategy.position_size < 0
    // use actual fill price for BE stop (not the limit order price)
    beStopPrice = not na(shortFilledEntry) ? shortFilledEntry : shortEntryStored
    // for partial exit before tp1, use original stop
    strategy.exit("S-P", from_entry="S", qty=shortHalfQty, stop=shortStopStored, limit=shortHalfwayStored, comment_loss="s-sl", comment_profit="s-tp1")
    // for remaining position, use BE stop if tp1 was hit, otherwise original stop
    finalStop = shortBEActive ? beStopPrice : shortStopStored
    strategy.exit("S-F", from_entry="S", stop=finalStop, limit=shortTargetStored, comment_loss="s-be", comment_profit="s-tp2")

// also maintain exits for pending orders (before fill, only after setup bar)
if is5m and inRTH and not hasTradedToday and strategy.position_size == 0
    if longSetupActive and bar_index > longSetupBar
        strategy.exit("L-P", from_entry="L", qty=longHalfQty, stop=longStopStored, limit=longHalfwayStored, comment_loss="l-sl", comment_profit="l-tp1")
        strategy.exit("L-F", from_entry="L", stop=longStopStored, limit=longTargetStored, comment_loss="l-sl", comment_profit="l-tp2")
    if shortSetupActive and bar_index > shortSetupBar
        strategy.exit("S-P", from_entry="S", qty=shortHalfQty, stop=shortStopStored, limit=shortHalfwayStored, comment_loss="s-sl", comment_profit="s-tp1")
        strategy.exit("S-F", from_entry="S", stop=shortStopStored, limit=shortTargetStored, comment_loss="s-sl", comment_profit="s-tp2")

// ----------------------------------------------------------------------------------------
// Cancel pending orders after cutoff and after RTH
// ----------------------------------------------------------------------------------------
if afterCutoff
    strategy.cancel("L")
    strategy.cancel("S")
    longSetupActive := false
    shortSetupActive := false
    longEntryStored := na
    shortEntryStored := na
    longSetupBar := na
    shortSetupBar := na

if not inRTH
    strategy.cancel("L")
    strategy.cancel("S")
    longSetupActive := false
    shortSetupActive := false
    longEntryStored := na
    shortEntryStored := na
    longSetupBar := na
    shortSetupBar := na

// ----------------------------------------------------------------------------------------
// flat at 15:50 - close any remaining position at market
// this should rarely happen since stops/targets should have filled
// ----------------------------------------------------------------------------------------
if inFlatWin and strategy.position_size != 0
    if strategy.position_size > 0
        strategy.close("L", comment="eod-flat")
    if strategy.position_size < 0
        strategy.close("S", comment="eod-flat")

// ----------------------------------------------------------------------------------------
// Visuals
// ----------------------------------------------------------------------------------------
// Plot ORB lines only until 12:00 (exchange time)
plotORB = inRTH and inEntryWin
plot(plotORB ? orbHigh : na, "ORB High", style=plot.style_linebr, linewidth=2, color=color.new(#18b79c, 0))
plot(plotORB ? orbLow  : na, "ORB Low",  style=plot.style_linebr, linewidth=2, color=color.new(#5d606b, 0))

// Plot 200 EMA (15m)
plot(ema200_15m, "200 EMA (15m)", color=color.new(color.blue, 0), linewidth=2)